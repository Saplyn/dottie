use std::{
    convert::Infallible,
    ffi::OsString,
    io::BufRead,
    os::unix::fs::MetadataExt,
    path::{Path, PathBuf},
    process::{Command, Output},
};

use clap::Args;
use log::{trace, warn};
use owo_colors::OwoColorize;
use thiserror::Error;

use crate::dir::{Dir, exists, get};

// LYN: Arguments

#[derive(Debug, Args)]
pub struct RunArg {
    /// The package(s) whose scripts will be run
    #[arg(
        value_name = "packages",
        group = "specify",
        required = true,
        help = "The package(s) whose scripts will be run"
    )]
    pub pkgs: Vec<String>,

    /// Run scripts for all packages
    #[arg(short, long, group = "specify", help = "Run scripts for all packages")]
    pub all: bool,

    /// Dry run mode, only prints what scripts would be run
    #[arg(
        short,
        long,
        help = "Dry run mode, only print what scripts would be run"
    )]
    pub dry: bool,
}

// LYN: Main

pub fn main(arg: &RunArg) -> eyre::Result<()> {
    let summary = if arg.all {
        run_all(arg)?
    } else {
        run_specified(arg)?
    };

    summary.display()?;

    Ok(())
}

// LYN: Run Summary

#[derive(Debug, Default)]
struct RunSummary {
    /// Packages whose scripts were ran and it's outputs
    outputs: Vec<RunOutput>,
    /// package names that do not exist
    non_exist: Vec<String>,
    /// package names that do not have scripts
    no_scripts: Vec<String>,
}

impl RunSummary {
    fn display(&self) -> eyre::Result<()> {
        println!("{}", "Run Summary:".bold().bright_green());

        for output in &self.outputs {
            println!(
                "- Package {} executed {} script(s)",
                format!("`{}`", output.pkg_name).yellow(),
                output.output_pack.len()
            );
            for pack in &output.output_pack {
                if let Some(output) = &pack.output {
                    if output.status.success() {
                        println!(
                            "  - {} finished successfully",
                            format!("`{}`", pack.script_name).cyan()
                        );
                    } else {
                        println!(
                            "  - {} finished with {}",
                            format!("`{}`", pack.script_name).cyan(),
                            output.status.bright_red()
                        );
                        println!("    - stdout");
                        for ln in output.stdout.lines() {
                            let ln = ln?;
                            println!("      {}", ln.bright_black());
                        }
                        println!("    - stderr");
                        for ln in output.stderr.lines() {
                            let ln = ln?;
                            println!("      {}", ln.bright_black());
                        }
                    }
                } else {
                    println!(
                        "  - {} would be ran",
                        format!("`{}`", pack.script_name).cyan()
                    );
                }
            }
        }
        for pkg_name in &self.non_exist {
            println!(
                "- Package {} doesn't exist",
                format!("`{}`", pkg_name).yellow()
            );
        }
        for pkg_name in &self.no_scripts {
            println!(
                "- Package {} have no scripts folder",
                format!("`{}`", pkg_name).yellow()
            );
        }
        Ok(())
    }
}

#[derive(Debug)]
struct RunOutput {
    /// The name of the package whose scripts were ran
    pkg_name: String,
    /// The output of the scripts ran for the package
    output_pack: Vec<RunOutputPack>,
}

#[derive(Debug)]
struct RunOutputPack {
    /// The name of the script that was run
    script_name: String,
    /// The output of the script, if not dry run
    output: Option<Output>,
}

// LYN: Run Scripts

#[derive(Debug, Error)]
enum RunError {
    #[error("Failed to parse UTF8 OsString: {0:?}")]
    InvalidUtf8OsString(OsString),
    #[error("Impossible nameless path generated by program: {0}")]
    ImpossibleNamelessPath(PathBuf),
}

/// Runs scripts for all packages.
fn run_all(arg: &RunArg) -> eyre::Result<RunSummary> {
    let mut summary = RunSummary::default();
    for pkg_entry in get(Dir::App).read_dir()? {
        let pkg_entry = pkg_entry?;
        let pkg_name = pkg_entry
            .file_name()
            .into_string()
            .map_err(RunError::InvalidUtf8OsString)?;
        if !exists(Dir::Scripts {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.no_scripts.push(pkg_name.to_owned());
            warn!("Package `{}` does not have a scripts folder", pkg_name);
            continue;
        }
        summary.outputs.push(RunOutput {
            pkg_name: pkg_name.clone(),
            output_pack: run_pack(&pkg_name, arg.dry)?,
        });
    }

    Ok(summary)
}

/// Runs scripts for specified packages.
fn run_specified(arg: &RunArg) -> eyre::Result<RunSummary> {
    let mut summary = RunSummary::default();
    for pkg_name in &arg.pkgs {
        if !exists(Dir::Pkg {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.non_exist.push(pkg_name.to_owned());
            warn!("Package `{}` does not exist", pkg_name);
            continue;
        }
        if !exists(Dir::Scripts {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.no_scripts.push(pkg_name.to_owned());
            warn!("Package `{}` does not have a scripts folder", pkg_name);
            continue;
        }
        summary.outputs.push(RunOutput {
            pkg_name: pkg_name.to_owned(),
            output_pack: run_pack(pkg_name, arg.dry)?,
        });
    }
    Ok(summary)
}

/// Runs scripts for a specific package, optionally in dry run mode.
fn run_pack(pkg_name: &str, dry: bool) -> eyre::Result<Vec<RunOutputPack>> {
    let mut output_pack = Vec::new();
    for entry in get(Dir::Scripts {
        pkg_name: pkg_name.to_owned(),
    })
    .read_dir()?
    {
        let entry = entry?;
        let path = entry.path();
        if !is_exetutable(&path)? {
            warn!("Skip non-executable file: {:?}", path);
            continue;
        }
        let script_name = path
            .file_name()
            .ok_or_else(|| RunError::ImpossibleNamelessPath(path.clone()))?
            .to_owned()
            .into_string()
            .map_err(RunError::InvalidUtf8OsString)?;

        trace!(
            "Executing script `{}` for package `{}`",
            script_name, pkg_name
        );

        let output = if dry {
            None
        } else {
            Some(Command::new(&path).output()?)
        };
        trace!("Script finished with output: {:?}", output);
        output_pack.push(RunOutputPack {
            script_name,
            output,
        });
    }
    Ok(output_pack)
}

#[cfg(unix)]
fn is_exetutable(path: &Path) -> eyre::Result<bool> {
    let meta = path.metadata()?;
    Ok(path.is_file() && meta.mode() & 0o100 != 0)
}

#[cfg(not(unix))]
fn is_exetutable(path: &Path) -> Result<bool, Infallible> {
    Ok(path
        .extension()
        .is_some_and(|ext| ext == "sh" || ext == "bat" || ext == "cmd" || ext == "exe"))
}
