use std::{
    ffi::OsString,
    os::unix::fs::MetadataExt,
    path::PathBuf,
    process::{Command, ExitStatus},
    sync::{Arc, Barrier, Mutex},
    thread,
};

use clap::Args;
use log::{error, info, trace, warn};
use nix::libc::pid_t;
use owo_colors::OwoColorize;
use signal_hook::{consts::SIGINT, iterator::Signals};
use thiserror::Error;

use crate::dir::{Dir, exists, get, not_package};

// LYN: Arguments

#[derive(Debug, Args)]
pub struct RunArg {
    /// The package(s) whose scripts will be run
    #[arg(
        value_name = "packages",
        group = "specify",
        required = true,
        help = "The package(s) whose scripts will be run"
    )]
    pub pkgs: Vec<String>,

    /// Run scripts for all packages
    #[arg(short, long, group = "specify", help = "Run scripts for all packages")]
    pub all: bool,

    /// Dry run mode, only prints what scripts would be run
    #[arg(
        short,
        long,
        help = "Dry run mode, only print what scripts would be run"
    )]
    pub dry: bool,
}

// LYN: Main

pub fn main(arg: &RunArg) -> eyre::Result<()> {
    let summary = if arg.all {
        run_all(arg)?
    } else {
        run_specified(arg)?
    };

    summary.display()?;

    Ok(())
}

// LYN: Run Summary

#[derive(Debug, Default)]
struct RunSummary {
    /// Packages whose scripts were ran and their statuses
    statuses: Vec<RunStatus>,
    /// package names that do not exist
    non_exist: Vec<String>,
    /// package names that do not have scripts
    no_scripts: Vec<String>,
}

impl RunSummary {
    fn display(&self) -> eyre::Result<()> {
        println!("{}", "Run Summary:".bold().bright_green());

        for status in &self.statuses {
            println!(
                "- Package {} executed {} script(s)",
                format!("`{}`", status.pkg_name).yellow(),
                status.status_pack.len()
            );
            for pack in &status.status_pack {
                if let Some(status) = &pack.status {
                    if status.success() {
                        println!(
                            "  - {} finished successfully",
                            format!("`{}`", pack.script_name).cyan()
                        );
                    } else {
                        println!(
                            "  - {} finished with {}",
                            format!("`{}`", pack.script_name).cyan(),
                            status.bright_red()
                        );
                    }
                } else {
                    println!(
                        "  - {} would be ran",
                        format!("`{}`", pack.script_name).cyan()
                    );
                }
            }
        }
        for pkg_name in &self.non_exist {
            println!(
                "- Package {} doesn't exist",
                format!("`{}`", pkg_name).yellow()
            );
        }
        for pkg_name in &self.no_scripts {
            println!(
                "- Package {} have no scripts folder",
                format!("`{}`", pkg_name).yellow()
            );
        }
        Ok(())
    }
}

#[derive(Debug)]
struct RunStatus {
    /// The name of the package whose scripts were ran
    pkg_name: String,
    /// The status of the scripts ran for the package
    status_pack: Vec<RunStatusPack>,
}

#[derive(Debug)]
struct RunStatusPack {
    /// The name of the script that was run
    script_name: String,
    /// The status of the script, if not dry run
    status: Option<ExitStatus>,
}

// LYN: Run Scripts

#[derive(Debug, Error)]
enum RunError {
    #[error("Failed to parse UTF8 OsString: {0:?}")]
    InvalidUtf8OsString(OsString),
    #[error("Impossible nameless path generated by program: {0}")]
    ImpossibleNamelessPath(PathBuf),
}

/// Runs scripts for all packages.
fn run_all(arg: &RunArg) -> eyre::Result<RunSummary> {
    let mut summary = RunSummary::default();
    for pkg_entry in get(Dir::App).read_dir()? {
        let pkg_entry = pkg_entry?;
        if not_package(&pkg_entry.path()) {
            info!("Skipping non backage entry: {:?}", pkg_entry);
            continue;
        }
        let pkg_name = pkg_entry
            .file_name()
            .into_string()
            .map_err(RunError::InvalidUtf8OsString)?;
        if !exists(Dir::Scripts {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.no_scripts.push(pkg_name.to_owned());
            warn!("Package `{}` does not have a scripts folder", pkg_name);
            continue;
        }
        summary.statuses.push(RunStatus {
            pkg_name: pkg_name.clone(),
            status_pack: run_pack(&pkg_name, arg.dry)?,
        });
    }

    Ok(summary)
}

/// Runs scripts for specified packages.
fn run_specified(arg: &RunArg) -> eyre::Result<RunSummary> {
    let mut summary = RunSummary::default();
    for pkg_name in &arg.pkgs {
        if !exists(Dir::Pkg {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.non_exist.push(pkg_name.to_owned());
            warn!("Package `{}` does not exist", pkg_name);
            continue;
        }
        if !exists(Dir::Scripts {
            pkg_name: pkg_name.to_owned(),
        })? {
            summary.no_scripts.push(pkg_name.to_owned());
            warn!("Package `{}` does not have a scripts folder", pkg_name);
            continue;
        }
        summary.statuses.push(RunStatus {
            pkg_name: pkg_name.to_owned(),
            status_pack: run_pack(pkg_name, arg.dry)?,
        });
    }
    Ok(summary)
}

/// Runs scripts for a specific package, optionally in dry run mode.
fn run_pack(pkg_name: &str, dry: bool) -> eyre::Result<Vec<RunStatusPack>> {
    let child_slot: Arc<Mutex<Option<u32>>> = Arc::new(Mutex::new(None));
    let mut signals = Signals::new([SIGINT])?;
    let handle = signals.handle();
    let killer_start = Arc::new(Barrier::new(2));
    {
        let child_slot = Arc::clone(&child_slot);
        let barrier = Arc::clone(&killer_start);
        thread::spawn(move || {
            let id = thread::current().id();
            info!("Child killer {:?} started", id);
            barrier.wait();
            for _ in signals.forever() {
                if let Some(child_pid) = child_slot.lock().unwrap().take() {
                    let _ = nix::sys::signal::kill(
                        nix::unistd::Pid::from_raw(child_pid as pid_t),
                        nix::sys::signal::Signal::SIGKILL,
                    );
                }
            }
            info!("Child killer {:?} suicided", id);
        });
    }

    killer_start.wait();
    let mut status_pack = Vec::new();
    for entry in get(Dir::Scripts {
        pkg_name: pkg_name.to_owned(),
    })
    .read_dir()?
    {
        let entry = entry?;
        let path = entry.path();
        let meta = path.metadata()?;
        if !path.is_file() || meta.mode() & 0o100 == 0 {
            warn!("Skip non-executable file: {:?}", path);
            continue;
        }
        let script_name = path
            .file_name()
            .ok_or_else(|| RunError::ImpossibleNamelessPath(path.clone()))?
            .to_owned()
            .into_string()
            .map_err(RunError::InvalidUtf8OsString)?;

        trace!(
            "Executing script `{}` for package `{}`",
            script_name, pkg_name
        );

        let status = if dry {
            None
        } else {
            println!(
                "{}",
                format!(
                    "Executing script {} for package {}",
                    format!("`{}`", script_name).black(),
                    format!("`{}`", pkg_name).yellow()
                )
                .on_blue()
            );
            let mut child = Command::new(&path)
                .stdin(std::process::Stdio::inherit())
                .stdout(std::process::Stdio::inherit())
                .stderr(std::process::Stdio::inherit())
                .spawn()?;

            *child_slot.lock().unwrap() = Some(child.id());
            let status = child.wait()?;
            *child_slot.lock().unwrap() = None;

            Some(status)
        };
        trace!("Script finished with status: {:?}", status);
        status_pack.push(RunStatusPack {
            script_name,
            status,
        });
    }

    handle.close();
    Ok(status_pack)
}
